解题思路:
  有两个字符串(s和p字符串)匹配的问题，在实现过程中一般会涉及到s中的第i个与p中的第j个字符进行匹配。
  由此进行深入，假设s[0->i]与p[0->j]匹配，那么必然s[i]与p[j]前面的子串也是匹配的，故这里就有一个最优子结构。 

  所以本题优先思考动态规划的方式，不妨将dp[i][j]表示为s中的前i个与p中的前j个字符是否匹配。
  假设dp[i][j] = true(即匹配), 下面就状态转移分情况讨论：
  (1)若p[j]为'a'-'z', 则:
      dp[i - 1][j - 1] == true  && s[i] == p[j] 
      
  (2)若p[j]为'.', 则: 
      dp[i - 1][j - 1] == true
      
  (3)若p[j]为'*'(*前必跟着一个字符), 则:
      p[j - 1]可能匹配0次或1次或多次:
        如果匹配0次的情况:
          dp[i][j - 2] == true

        如果匹配1次的情况:
          dp[i - 1][j - 2] == true && s[i] == p[j - 1]

        如果匹配2次的情况:
          dp[i - 2][j - 2] == true && s[i] == p[j - 1] && s[i - 1] == p[j - 1]
        
        如果匹配n次的情况:
          dp[i - n][j - 2] == true && s[i] == p[j - 1] && s[i - 1] == p[j - 1] ... && ... s[i - n + 1] == p[j - 1]

  由以上分析, 状态转移方程为:
    dp[i][j] = 
        (1) dp[i - 1][j - 1] && p[j] > 'a' && p[j] < 'z' && s[i] == p[j]
        (2) dp[i - 1][j - 1] && p[j] == '.'
        (3) { k ∈ n |  dp[i - k][ j - 2] && p[j] == '*' && s[i - k + 1] == p[j - 1]}  // 特殊说明: 连续的字符才行, 并且如果p[j - 1]是'.', 则满足任意字符

   为方便编程,将下标转换一下:
    dp[i + 1][j + 1] = 
        (1) dp[i][j] && p[j + 1] > 'a' && p[j + 1] < 'z' && s[i + 1] == p[j + 1]
        (2) dp[i][j] && p[j + 1] == '.'
        (3) { k ∈ n |  dp[i - k + 1][ j - 1] && p[j + 1] == '*' && s[i - k + 2] == p[j]}  // 特殊说明: 连续的字符才行, 并且如果p[j]是'.', 则满足任意字符
    此种状态转移方程看起来还是有点复杂，需要优化的感觉，但是先写下代码，看能否写出来。


  遇到这种题目不要慌，耐心的一点一点分析下来，就能做出来。
  这题明显就是自顶向下分析，自底向上实现。


代码:












