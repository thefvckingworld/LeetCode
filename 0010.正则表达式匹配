解题思路:
  有两个字符串(s和p字符串)匹配的问题，在实现过程中一般会涉及到s中的第i个与p中的第j个字符进行匹配。
  由此进行深入，假设s[0->i]与p[0->j]匹配，那么必然s[i]与p[j]前面的子串也是匹配的，故这里就有一个最优子结构。 

  所以本题优先思考动态规划的方式，不妨将dp[i][j]表示为s中的前i个与p中的前j个字符是否匹配。
  假设dp[i][j] = true(即匹配), 下面就状态转移分情况讨论：
  (1)若p[j]为'a'-'z', 则:
      dp[i - 1][j - 1] == true  && s[i] == p[j] 
      
  (2)若p[j]为'.', 则: 
      dp[i - 1][j - 1] == true
      
  (3)若p[j]为'*'(*前必跟着一个字符), 则:
      p[j - 1]可能匹配0次或1次或多次:
        如果匹配0次的情况:
          dp[i][j - 2] == true

        如果匹配1次的情况:
          dp[i - 1][j - 2] == true && s[i] == p[j - 1]

        如果匹配2次的情况:
          dp[i - 2][j - 2] == true && s[i] == p[j - 1] && s[i - 1] == p[j - 1]
        
        如果匹配n次的情况:
          dp[i - n][j - 2] == true && s[i] == p[j - 1] && s[i - 1] == p[j - 1] ... && ... s[i - n + 1] == p[j - 1]

  由以上分析, 状态转移方程为:
    dp[i][j] = 
        (1) dp[i - 1][j - 1] && p[j] > 'a' && p[j] < 'z' && s[i] == p[j]
        (2) dp[i - 1][j - 1] && p[j] == '.'
        (3) { k ∈ n |  dp[i - k][ j - 2] && p[j] == '*' && s[i - k + 1] == p[j - 1]}  // 特殊说明: 如果p[j - 1]是'.', 则满足任意字符
            对于第三种情况,需要继续进行分析优化, 先把第三种情况的写法简化一下(k次匹配):
            dp[i][j] = dp[i][j - 2] || (dp[i - 1][j - 2] && s[i] = p[j - 1]) || (dp[i - 2][j - 2] && s[i, i-1] = p[j - 1]) || ... || (dp[i - k][j - 2] && s[i...i - k + 1] = p[j - 1])
            我们发现当k项不确定时，dp[i][j]的项也是不确定的，自然而然的想到使用类似于等差数列的概念，用dp[i][j]前的某一个项来代替掉后续k项，因为如dp[i - m][j - m]也肯定是类似的k项组成的。
            
            对于dp[i][j]匹配0次,  实际问题退化到dp[i - 1][j - 2] = true, 且s[i] == p[j + 1]
            对于dp[i][j]匹配1次,  实际dp[i - 1][j] 匹配0次
            对于dp[i][j]匹配2次,  实际dp[i -1 ][j] 匹配1次
            可得：对于dp[i][j]匹配k次,  实际dp[i -1 ][j] 匹配k - 1次
            可得dp[i - 1][j - 1] = dp[i - 1][j - 2] || (dp[i - 2][j - 2] && s[i - 1] = p[j - 1]) || ... || (dp[(i - 1) - (k - 1)][j - 2] && s[i - 1, i, ... (i - 1 - k + 1 + 1)] = p[j - 1])



  遇到这种题目不要慌，耐心的一点一点分析下来，就能做出来。
  这题明显就是自顶向下分析，自底向上实现。


代码:












